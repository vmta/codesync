#!/usr/bin/env bash



source common/repository;
source common/test1;


FLAG_UPDATE=0;


# 1. find out if we need to update
# 2. find out if we need to get patches
# 3. run word processor to change
# 4. get patches



if [[ $# -gt 0 ]]; then

    while getopts "u" opt; do

        case $opt in

            u)  # Fetch and merge updates
                FLAG_UPDATE=1;
                ;;

        esac

    done

    # From CLONE, retrieve SHA1 of the last synced commit
    pushd $CLONE;
    if [ $FLAG_UPDATE -eq 1 ]; then
        updateRepo;
    fi
    LAST_SYNCED_COMMIT=$( getLastSyncedCommit );
    popd;

    # From MAINSTREAM, retrieve SHA1 of the first unsynced commit
    # but first, need to fetch and merge and then get the first unsynced
    # then rewind to the previous state.
    pushd $MAINSTREAM;
    CURRENT_HEAD=$( getHEAD );
    git fetch origin $BRANCH;
    git merge FETCH_HEAD;
    FIRST_UNSYNCED_COMMIT=$( getFirstUnsyncedCommit $LAST_SYNCED_COMMIT );
    git reset --hard $CURRENT_HEAD;
    popd;

    # check that last synced and first unsynced differ,
    # even simpler, the first unsynced would be empty if
    # repos are in sync

    if [ ! -z $FIRST_UNSYNCED_COMMIT ]; then


        pushd $MAINSTREAM;


            git fetch origin $BRANCH;
            git merge $FIRST_UNSYNCED_COMMIT;


        popd;


    fi

else

    # display help and usage info and exit
    echo "Will echo help and usage";

fi



exit $?
